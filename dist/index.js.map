{"mappings":";;;;;;;;;;;ACAA,MAAM,4CAAK,CAAC,YAAY;IACpB,OAAO,aAAa;AACxB;AAEA,MAAM,2CAAM,CAAC,MAAM,aAAa,GAAG,EAAE,aAAa,KAAK;IACnD,OAAO,KAAK,MAAM,OAAO,0CAAG,YAAY;AAC5C;AAEA,MAAM,4CAAO,CAAC,KAAK,aAAa,GAAG,EAAE,aAAa,KAAK;IACnD,OAAO,MAAM,0CAAG,YAAY;AAChC;AAEA,MAAM,4CAAU,CAAC,QAAQ,UAAU,CAAC,CAAC;IACjC,UAAU,OAAO,OAAO;QACpB,YAAY;QACZ,WAAW,OAAO;QAClB,SAAS;IACb,GAAG;IACH,QAAQ,aAAa,SAAS,QAAQ;IACtC,QAAQ,YAAY,SAAS,QAAQ;IACrC,MAAM,iBAAiB,MAAM;IAC7B,IAAI,MAAM,EAAE;IACZ,IAAK,IAAI,IAAE,GAAG,IAAE,OAAO,QAAQ,KAAK,QAAQ,UAAW;QACnD,IAAI,MAAM,OAAO,MAAM,GAAG,IAAI,QAAQ;QACtC,IAAI,IAAI,SAAS,QAAQ,WACrB,MAAM,IAAI,MAAM,KAAK,KAAK,SAAS,IAAI;QAE3C,MAAM,aAAa,QAAQ;QAC3B,IAAI,OAAO,MAAM,QAAQ,QAAQ,SAAS;QAC1C,IAAI,KAAK;IACb;IACA,MAAM,aAAa;IACnB,OAAO,IAAI,SAAS,IAAI,MAAM,GAAG,CAAC,EAAE;AACxC;AAEA,MAAM,4CAAO,CAAC,KAAK,UAAU,CAAC,CAAC;IAC3B,UAAU,OAAO,OAAO;QACpB,YAAY;QACZ,OAAO;QACP,OAAO;IACX,GAAG;IACH,IAAI,QAAQ,QAAQ,GAChB,QAAQ,QAAQ,QAAQ,aAAa,IAAI;IAE7C,MAAM,WAAW,CAAC;QACd,OAAO,MAAM,MAAM,QAAQ,OAAO,QAAQ,QAAQ;IACtD;IACA,IAAI,MAAM,QAAQ,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC,EAAE,YAAY,cAC3C,OAAO,IAAI,IAAI;IAEnB,OAAO,SAAS;AACpB;;;ADjDA,OAAO,MAAM","sources":["src/index.js","src/fft.js"],"sourcesContent":["import * as fft from \"./fft\";\n\nwindow.fft = fft;\n","const bw = (bufferSize, sampleRate) => {\n    return sampleRate / bufferSize;\n}\n\nconst bin = (freq, bufferSize = 512, sampleRate = 44100) => {\n    return Math.floor(freq / bw(bufferSize, sampleRate));\n}\n\nconst freq = (bin, bufferSize = 512, sampleRate = 44100) => {\n    return bin * bw(bufferSize, sampleRate);\n}\n\nconst extract = (signal, options = {}) => {\n    options = Object.assign({\n        bufferSize: 512,\n        chunkSize: signal.length,\n        feature: \"amplitudeSpectrum\",\n    }, options);\n    options.bufferSize = parseInt(options.bufferSize);\n    options.chunkSize = parseInt(options.chunkSize);\n    const origBufferSize = Meyda.bufferSize;\n    let fft = [];\n    for (let i=0; i<signal.length; i += options.chunkSize) {\n        let sig = signal.slice(i, i + options.chunkSize);\n        if (sig.length < options.chunkSize) {\n            sig = arr.padTo(sig, math.nextPow2(sig.length));\n        }\n        Meyda.bufferSize = options.bufferSize;\n        let data = Meyda.extract(options.feature, sig);\n        fft.push(data);\n    }\n    Meyda.bufferSize = origBufferSize;\n    return fft.length > 1 ? fft : fft[0];\n}\n\nconst band = (fft, options = {}) => {\n    options = Object.assign({\n        bufferSize: 512,\n        loBin: 0,\n        hiBin: 0,\n    }, options);\n    if (options.hiBin < 0) {\n        options.hiBin = options.bufferSize / 2 - 1;\n    }\n    const chunkAvg = (chunk) => {\n        return chunk.slice(options.loBin, options.hiBin + 1);\n    };\n    if (Array.isArray(fft[0]) || fft[0] instanceof Float32Array) {\n        return fft.map(chunkAvg);\n    }\n    return chunkAvg(fft);\n}\n\nexport { bw, bin, freq, extract, band };"],"names":[],"version":3,"file":"index.js.map"}